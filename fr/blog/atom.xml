<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pnpm.io/fr/blog</id>
    <title>pnpm Blog</title>
    <updated>2021-12-29T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pnpm.io/fr/blog"/>
    <subtitle>pnpm Blog</subtitle>
    <icon>https://pnpm.io/fr/img/favicon.png</icon>
    <entry>
        <title type="html"><![CDATA[The year 2021 for pnpm]]></title>
        <id>/2021/12/29/yearly-update</id>
        <link href="https://pnpm.io/fr/blog/2021/12/29/yearly-update"/>
        <updated>2021-12-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[It is the end of the year and it was a good year for pnpm, so let's see how it went.]]></summary>
        <content type="html"><![CDATA[<p>It is the end of the year and it was a good year for pnpm, so let&#x27;s see how it went.</p><h2>Usage</h2><h3>Download Stats</h3><p>My goal this year was to beat Bower by the number of downloads. We were able to achieve this goal <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29">in November</a>:</p><p><img src="/img/blog/pnpm-vs-bower-stats.png"/></p><p>pnpm was downloaded about <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29">3 times more</a> in 2021 than in 2020:</p><p><img src="/img/blog/download-stats-2021.png"/></p><p>:::note</p><p>These stats don&#x27;t even measure all the different ways that pnpm may be installed! They only measure the downloads of the <a href="https://www.npmjs.com/package/pnpm">pnpm npm package</a>. This year we also added compiled binary versions of pnpm, which are shipped differently.</p><p>:::</p><h3>Docs visits</h3><p>We collect some unpersonalized stats from our docs using Google Analytics. In 2021, sometimes we had more than 2,000 unique visitors a week.</p><p><img src="/img/blog/ga-unique-visits-2021.png"/></p><p>Most of our users are from the United States and China.</p><p><img src="/img/blog/countries-2021.png"/></p><h3>GitHub stars</h3><p>Our <a href="https://github.com/pnpm/pnpm">main GitHub repository</a> received +5,000 stars this year.</p><p><img src="/img/blog/stars-2021.png"/></p><h3>New users</h3><p>Our biggest new user this year is <a href="https://github.com/pnpm/pnpm.github.io/pull/89">Bytedance</a> (the company behind TikTok).</p><p>Also, many great open-source projects started to use pnpm. Some switched to pnpm because of its great support of monorepos:</p><ul><li><a href="https://github.com/vuejs/vue-next">Vue</a></li><li><a href="https://github.com/vitejs/vite">Vite</a></li><li>and <a href="https://pnpm.io/workspaces#usage-examples">others</a></li></ul><p>Some switched because they like how efficient, fast, and beautiful pnpm is:</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419">Browserslist</a></li></ul><h2>Feature Highlights</h2><h3>New lockfile format (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0">v6.0.0</a>)</h3><p>One of the first and most important changes this year was the new <code>pnpm-lock.yaml</code> format. This was a breaking change, so we had to release v6. But it was a success. The old lockfile was causing Git conflicts frequently. Since the new format was introduced, we did not receive any complaints about Git conflicts.</p><h3>Managing Node.js versions (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0">v6.12.0</a>)</h3><p>We shipped a new command (<code>pnpm env</code>) that allows to manage Node.js versions. So you may use pnpm instead of Node.js version managers like nvm or Volta.</p><p>Also, pnpm is shipped as a standalone executable, so you can run it even with no Node.js preinstalled on the system.</p><h3>Injecting local dependencies (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0">v6.20.0</a>)</h3><p>You may &quot;inject&quot; a local dependency. By default, local dependencies are symlinked to <code>node_modules</code> but with this new feature you may instruct pnpm to hard link the files of the package instead.</p><h3>Improved reporting of peer dependency issues (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0">v6.24.0</a>)</h3><p>Peer dependency issues used to be printed as plain text and it was hard to understand them. They are now all grouped and printed in a nice hierarchy structure.</p><h2>The Competition</h2><h3>Yarn</h3><p>Yarn added a pnpm linker in <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-">v3.1</a>. So Yarn can create a similar node-modules directory structure to the one that pnpm creates.</p><p>Also, the Yarn team plans to implement a content-addressable storage to be more disk space efficient.</p><h3>npm</h3><p>The npm team decided to also adopt the symlinked node-modules directory structure that pnpm uses (related <a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md">RFC</a>).</p><h3>Others</h3><p><a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1">Bun</a> written in Zig and <a href="https://github.com/voltpkg/volt">Volt</a> written in Rust both claim to be faster than npm/Yarn/pnpm. I did not benchmark these new package managers yet.</p><h2>Future Plans</h2><p>Faster, better, best.</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Options de configuration des node_modules avec pnpm]]></title>
        <id>/2020/10/17/node-modules-configuration-options-with-pnpm</id>
        <link href="https://pnpm.io/fr/blog/2020/10/17/node-modules-configuration-options-with-pnpm"/>
        <updated>2020-10-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Il existe de nombreuses façons de créer un dossier nodemodules. Votre objectif doit être de créer le plus strict, mais si ce n'est pas possible, il y a aussi des options pour faire un nodemodules en vrac.]]></summary>
        <content type="html"><![CDATA[<p>Il existe de nombreuses façons de créer un dossier node_modules. Votre objectif doit être de créer le plus strict, mais si ce n&#x27;est pas possible, il y a aussi des options pour faire un node_modules en vrac.</p><h2>Configuration par défaut</h2><p>Par défaut, pnpm v5 créera un node_modules semi-strict. Semi-strict signifie que votre application ne pourra require que des packages ajoutés en tant que dépendances au <code>package.json</code> (à quelques exceptions près). Cependant, vos dépendances pourront accéder à tous les packages.</p><p>La configuration par défaut ressemble à ceci:</p><pre><code class="language-ini">; Tous les packages sont hissés vers node_modules/.pnpm/node_modules
hoist-pattern[]=*

; Tous les types sont hissés à la racine afin de rendre TypeScript heureux
public-hoist-pattern[]=*types*

; Tous les packages liés à ESLint sont également hissés à la racine
public-hoist-pattern[]=*eslint*
</code></pre><h2>Plug&#x27;n&#x27;Play. La configuration la plus stricte</h2><p>pnpm prend en charge <a href="https://yarnpkg.com/features/pnp">Yarn&#x27;s Plug&#x27;n&#x27;Play</a> depuis la version 5.9. Avec PnP, votre application et les dépendances de votre application n&#x27;auront accès qu&#x27;à leurs dépendances déclarées. C&#x27;est encore plus strict que de définir <code>hoist=false</code> car à l&#x27;intérieur d&#x27;un monodépôt, votre application ne pourra même pas accéder aux dépendances du projet racine.</p><p>Pour utiliser Plug&#x27;n&#x27;Play, définissez ces paramètres:</p><pre><code class="language-ini">node-linker=pnp
symlink=false
</code></pre><h2>Un répertoire de node_modules strict et traditionnel</h2><p>Si vous n&#x27;êtes pas encore prêt à utiliser PnP, vous pouvez toujours être strict et autoriser uniquement les packages à accéder à leurs propres dépendances en définissant la configuration de hoist sur false:</p><pre><code class="language-ini">hoist=false
</code></pre><p>Cependant, si certaines de vos dépendances tentent d&#x27;accéder à des packages qui ne figurent pas dans leurs dépendances, vous avez deux options:</p><ol><li><p>Créez un <code>pnpmfile.js</code> et utilisez un <a href="/pnpmfile">crochet</a> pour ajouter la dépendance manquante au manifeste du package.</p></li><li><p>Ajoutez un pattern au paramètre <code>hoist-pattern</code>. Par exemple, si le module non trouvé est <code>babel-core</code>, ajoutez le paramètre suivant à <code>.npmrc</code>:</p><pre><code class="language-ini">hoist-pattern[]=babel-core
</code></pre></li></ol><h2>Le pire des cas - hisser à la racine</h2><p>Certains outils peuvent ne pas fonctionner même avec la configuration par défaut de pnpm, qui héberge tout à la racine du magasin virtuel et quelques packages à la racine. Dans ce cas, vous pouvez hisser tout ou un sous-ensemble de dépendances à la racine du répertoire des modules.</p><p>Tout placer à la racine de node_modules:</p><pre><code class="language-ini">shamefully-hoist=true
</code></pre><p>Ne hisser que les packages qui correspondent à un modèle:</p><pre><code class="language-ini">public-hoist-pattern[]=babel-*
</code></pre>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flat node_modules n'est pas le seul moyen]]></title>
        <id>/2020/05/27/flat-node-modules-is-not-the-only-way</id>
        <link href="https://pnpm.io/fr/blog/2020/05/27/flat-node-modules-is-not-the-only-way"/>
        <updated>2020-05-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Les nouveaux utilisateurs de pnpm me posent souvent des questions sur la structure bizarre du dossier node_modules que pnpm créé. Pourquoi n'est-il pas plat ? Où sont toutes les sous-dépendances ?]]></summary>
        <content type="html"><![CDATA[<p>Les nouveaux utilisateurs de pnpm me posent souvent des questions sur la structure bizarre du dossier <code>node_modules</code> que pnpm créé. Pourquoi n&#x27;est-il pas plat ? Où sont toutes les sous-dépendances ?</p><blockquote><p>Je vais supposer que les lecteurs de cet article sont déjà familiers avec les <code>node_modules</code> plats créés par npm et Yarn. Si vous ne comprenez pas pourquoi npm 3 a dû commencer à utiliser <code>node_modules</code> en v3, vous pouvez trouver un peu de préhistoire dans <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">Pourquoi devrait-on utiliser pnpm ?</a>.</p></blockquote><p>Alors pourquoi les <code>node_modules</code> de pnpm sont inhabituels ? Créons deux répertoires et éxecutons <code>npm add express</code> dans l&#x27;un d&#x27;eux et <code>pnpm add express</code> dans l&#x27;autre. Voilà ce que vous obtenez dans le <code>node_modules</code> du premier répertoire:</p><pre><code class="language-text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express
</code></pre><p>Vous pouvez voir tout le répertoire <a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">ici</a>.</p><p>Et voici ce que vous obtenez dans les <code>node_modules</code> créés par pnpm:</p><pre><code class="language-text">.pnpm
.modules.yaml
express
</code></pre><p>Vous pouvez vérifier <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">ici</a>.</p><p>Alors, où sont toues les dépendances ? Il y a qu&#x27;un seul dossier dans les <code>node_modules</code> appelé <code>.pnpm</code> et il y a un lien symbolique appelé <code>express</code>. Et bien, nous n&#x27;avons installé que <code>express</code>, c&#x27;est donc le seul package auquel votre application doit avoir accès</p><blockquote><p>En savoir plus sur pourquoi la rigueur de pnpm est une bonne chose <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">ici</a></p></blockquote><p>Voyons ce qu&#x27;il y a à l&#x27;intérieur d&#x27;<code>express</code>:</p><pre><code class="language-text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
    .modules.yaml
</code></pre><p><code>express</code> n&#x27;a pas de <code>node_modules</code> ? Où sont toutes les dépendances d&#x27;<code>express</code> ?</p><p>L&#x27;astuce est qu&#x27;<code>express</code> n&#x27;est qu&#x27;un lien symbolique. Lorsque Node.js résout les dépendances, il utilise leurs emplacements réels, il ne conserve donc pas les liens symboliques. Mais où est l&#x27;emplacement réel d&#x27;<code>express</code>, vous vous demandez ?</p><p>Ici: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules/.pnpm/express@4.17.1/node_modules/express</a>.</p><p>OK, alors maintenant nous connaissons l&#x27;utilité du dossier <code>.pnpm/</code>. <code>.pnpm/</code> stocke tous les packages dans une structure de dossiers plats, de sorte que chaque package peut être trouvé dans un dossier nommé par ce modèle:</p><pre><code class="language-text">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;
</code></pre><p>On appelle ça le dossier du stockage virtuel.</p><p>Cette structure plate évite les problèmes de long chemin causés par les <code>node_modules</code> créés par npm v2 mais maintient les packages isolés, contrairement aux <code>node_modules</code> plats créés par npm v 3, 4, 5, 6 ou bien Yarn v1.</p><p>Regardons maintenant le réel emplacement d&#x27;<code>express</code>:</p><pre><code class="language-text">  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>Est-ce une arnaque ? Il manque encore <code>node_modules</code> ! La deuxième astuce de la structure des <code>node_modules</code> de pnpm est que les dépendances des packages se trouvent au même niveau de répertoire que l&#x27;emplacement réel du package dépendant. Donc les dépendances d&#x27;<code>express</code> ne sont pas dans <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code> mais dans <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm/express@4.17.1/node_modules/</a>:</p><pre><code class="language-text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
</code></pre><p>Toutes les dépendances d&#x27;<code>express</code> sont des liens symboliques vers des dossiers appropriés dans <code>node_modules/.pnpm/</code>. Placer les dépendances d&#x27;<code>express</code> un niveau supérieur permet d&#x27;éviter les liens symboliques circulaires.</p><p>Donc, comme vous pouvez le voir, même si la structure <code>node_modules</code> pnpm semble inhabituelle au premier abord:</p><ol><li>il est complètement compatible avec Node.js</li><li>les packages sont bien regroupés avec leurs dépendances</li></ol><p>La structure est un peu <a href="/how-peers-are-resolved">plus complexe</a> pour les packages avec des dépendances paires mais l&#x27;idée est la même: utiliser des liens symboliques pour créer une imbrication avec une structure de dossier plate.</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
</feed>