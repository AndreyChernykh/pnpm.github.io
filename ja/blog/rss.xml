<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>pnpm Blog</title>
        <link>https://pnpm.io/ja/blog</link>
        <description>pnpm Blog</description>
        <lastBuildDate>Wed, 29 Dec 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[The year 2021 for pnpm]]></title>
            <link>https://pnpm.io/ja/blog/2021/12/29/yearly-update</link>
            <guid>/2021/12/29/yearly-update</guid>
            <pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[It is the end of the year and it was a good year for pnpm, so let's see how it went.]]></description>
            <content:encoded><![CDATA[<p>It is the end of the year and it was a good year for pnpm, so let&#x27;s see how it went.</p><h2>使い方</h2><h3>Download Stats</h3><p>My goal this year was to beat Bower by the number of downloads. We were able to achieve this goal <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29">in November</a>:</p><p><img src="/img/blog/pnpm-vs-bower-stats.png"/></p><p>pnpm was downloaded about <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29">3 times more</a> in 2021 than in 2020:</p><p><img src="/img/blog/download-stats-2021.png"/></p><p>:::note</p><p>These stats don&#x27;t even measure all the different ways that pnpm may be installed! They only measure the downloads of the <a href="https://www.npmjs.com/package/pnpm">pnpm npm package</a>. This year we also added compiled binary versions of pnpm, which are shipped differently.</p><p>:::</p><h3>Docs visits</h3><p>We collect some unpersonalized stats from our docs using Google Analytics. In 2021, sometimes we had more than 2,000 unique visitors a week.</p><p><img src="/img/blog/ga-unique-visits-2021.png"/></p><p>Most of our users are from the United States and China.</p><p><img src="/img/blog/countries-2021.png"/></p><h3>GitHub stars</h3><p>Our <a href="https://github.com/pnpm/pnpm">main GitHub repository</a> received +5,000 stars this year.</p><p><img src="/img/blog/stars-2021.png"/></p><h3>New users</h3><p>Our biggest new user this year is <a href="https://github.com/pnpm/pnpm.github.io/pull/89">Bytedance</a> (the company behind TikTok).</p><p>Also, many great open-source projects started to use pnpm. Some switched to pnpm because of its great support of monorepos:</p><ul><li><a href="https://github.com/vuejs/vue-next">Vue</a></li><li><a href="https://github.com/vitejs/vite">Vite</a></li><li>and <a href="https://pnpm.io/workspaces#usage-examples">others</a></li></ul><p>Some switched because they like how efficient, fast, and beautiful pnpm is:</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419">Browserslist</a></li></ul><h2>Feature Highlights</h2><h3>New lockfile format (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0">v6.0.0</a>)</h3><p>One of the first and most important changes this year was the new <code>pnpm-lock.yaml</code> format. This was a breaking change, so we had to release v6. But it was a success. The old lockfile was causing Git conflicts frequently. Since the new format was introduced, we did not receive any complaints about Git conflicts.</p><h3>Managing Node.js versions (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0">v6.12.0</a>)</h3><p>We shipped a new command (<code>pnpm env</code>) that allows to manage Node.js versions. So you may use pnpm instead of Node.js version managers like nvm or Volta.</p><p>Also, pnpm is shipped as a standalone executable, so you can run it even with no Node.js preinstalled on the system.</p><h3>Injecting local dependencies (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0">v6.20.0</a>)</h3><p>You may &quot;inject&quot; a local dependency. By default, local dependencies are symlinked to <code>node_modules</code> but with this new feature you may instruct pnpm to hard link the files of the package instead.</p><h3>Improved reporting of peer dependency issues (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0">v6.24.0</a>)</h3><p>Peer dependency issues used to be printed as plain text and it was hard to understand them. They are now all grouped and printed in a nice hierarchy structure.</p><h2>The Competition</h2><h3>Yarn</h3><p>Yarn added a pnpm linker in <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-">v3.1</a>. So Yarn can create a similar node-modules directory structure to the one that pnpm creates.</p><p>Also, the Yarn team plans to implement a content-addressable storage to be more disk space efficient.</p><h3>npm</h3><p>The npm team decided to also adopt the symlinked node-modules directory structure that pnpm uses (related <a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md">RFC</a>).</p><h3>Others</h3><p><a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1">Bun</a> written in Zig and <a href="https://github.com/voltpkg/volt">Volt</a> written in Rust both claim to be faster than npm/Yarn/pnpm. I did not benchmark these new package managers yet.</p><h2>Future Plans</h2><p>Faster, better, best.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pnpm でのノードモジュールに関するオプション設定]]></title>
            <link>https://pnpm.io/ja/blog/2020/10/17/node-modules-configuration-options-with-pnpm</link>
            <guid>/2020/10/17/node-modules-configuration-options-with-pnpm</guid>
            <pubDate>Sat, 17 Oct 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[nodemodules ディレクトリを生成する方法は多くあります。 ゆるい nodemodules を作成する方法もありますが、ここでの目標は最も厳格なものを生成することです。]]></description>
            <content:encoded><![CDATA[<p>node_modules ディレクトリを生成する方法は多くあります。 ゆるい node_modules を作成する方法もありますが、ここでの目標は最も厳格なものを生成することです。</p><h2>デフォルトの構築方法</h2><p>デフォルトでは、pnpm v5 は準厳格な node_modules を作成します。 準厳格な場合は、アプリケーションからは<code>package.json</code> に依存として追加されているパッケージのみを require できます。(いくつかの例外を除きます。) ただし、依存関係はどのパッケージにもアクセスすることができます。</p><p>デフォルトの設定は以下のようになります:</p><pre><code class="language-ini">; すべてのパッケージを node_modules/.pnpm/node_modules に巻き上げる
hoist-pattern[]=*

; TypeScript でうまく扱えるように、すべての型定義をルートに巻き上げる
public-hoist-pattern[]=*types*

; すべての ESLint に関係するパッケージをルートに巻き上げる
public-hoist-pattern[]=*eslint*
</code></pre><h2>プラグ・アンド・プレイ。 最も厳格な設定</h2><p>pnpm は v5.9 から <a href="https://yarnpkg.com/features/pnp">Yarn の プラグ・アンド・プレイ</a> をサポートしています。 プラグ・アンド・プレイでは、アプリケーションも、その依存も、宣言された依存にのみアクセスできるようになります。 この設定は <code>hoist=false</code> を設定するよりもさらに厳格です。モノレポの中では、アプリケーションはたとえルートの依存にすらアクセスできないからです。</p><p>プラグ・アンド・プレイを使用するには、次の設定を使用してください。</p><pre><code class="language-ini">node-linker=pnp
symlink=false
</code></pre><h2>厳格で伝統的なモジュールディレクトリの構造</h2><p>まだプラグ・アンド・プレイを使用する準備ができていない場合でも、hoist を false に設定することにより、パッケージが自身の依存にのみアクセスできるようにすることが可能です。</p><pre><code class="language-ini">hoist=false
</code></pre><p>しかし、いくつかの依存が、その依存にないパッケージへのアクセスを試みようとする場合は、2つの方法があります。</p><ol><li><p><code>pnpmfile.js</code> を作成して、<a href="/pnpmfile">hook</a> を使用して不足している依存をパッケージのマニフェストに加える。</p></li><li><p><code>hoist-pattern</code> 設定にパターンを追加する。 例えば、見つからないモジュールが <code>babel-core</code> の場合は、次の設定を <code>.npmrc</code> に追記します。</p><pre><code class="language-ini">hoist-pattern[]=babel-core
</code></pre></li></ol><h2>最も悪いケース - ルートへの巻き上げ</h2><p>一部のツールは、すべてを仮想ストアのルートに、一部のパッケージをルートに巻き上げる pnpm のデフォルト設定でも機能しない場合があります。 この場合、依存のすべて、または一部をモジュールディレクトリのルートに引き上げることができます。</p><p>node_modules のルートにすべてを巻き上げる場合:</p><pre><code class="language-ini">shamefully-hoist=true
</code></pre><p>パターンにマッチしたパッケージのみを巻き上げる場合:</p><pre><code class="language-ini">public-hoist-pattern[]=babel-*
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[フラットな node_modules が唯一の方法ではありません]]></title>
            <link>https://pnpm.io/ja/blog/2020/05/27/flat-node-modules-is-not-the-only-way</link>
            <guid>/2020/05/27/flat-node-modules-is-not-the-only-way</guid>
            <pubDate>Wed, 27 May 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[pnpm の新規ユーザーから、pnpm が生成する node_modules の奇妙な構造についてよく聞かれます。 なぜ平坦な構造を使用しないのでしょうか。 依存のさらにその依存はどこにあるのでしょうか。]]></description>
            <content:encoded><![CDATA[<p>pnpm の新規ユーザーから、pnpm が生成する <code>node_modules</code> の奇妙な構造についてよく聞かれます。 なぜ平坦な構造を使用しないのでしょうか。 依存のさらにその依存はどこにあるのでしょうか。</p><blockquote><p>この記事では、npm や Yarn の生成するフラットな <code>node_modules</code> に馴染みのある読者を想定しています。 npm が v3 からフラットな <code>node_modules</code> を採用する必要があった理由については、 <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">なぜ pnpm が必要なのでしょうか (英語)</a> を参照してください。</p></blockquote><p>では、なぜ pnpm は通常とは異なる構造の <code>node_modules</code> を使用するのでしょう。 試しに 2 つのディレクトリを作成して、片方には <code>npm add express</code> を、もう一方には <code>pnpm add express</code> を実行してみてください。 npm の方のディレクトリにある <code>node_modules</code> は次のようになります。</p><pre><code class="language-text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express
</code></pre><p><a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">こちら</a> でディレクトリ全体を確認できます。</p><p>そして、こちらが pnpm が生成する <code>node_modules</code> は次のようになります。</p><pre><code class="language-text">.pnpm
.modules.yaml
express
</code></pre><p><a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">こちら</a> からディレクトリ全体を確認できます。</p><p>依存のすべてはどこにあるのでしょうか。 <code>node_modules</code> 配下には、フォルダは <code>.pnpm</code> のみが存在し、あとは <code>express</code> という名前のシンボリックリンクです。 今回、 <code>express</code> しかインストールしていないため、アプリケーションからアクセスできるパッケージはこれのみなのです。</p><blockquote><p>pnpm のこの厳格さがどうしていいのか、ということにういては <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">こちら</a> を参照してください。</p></blockquote><p><code>express</code> の中身がどうなっているか確認してみましょう。</p><pre><code class="language-text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
    .modules.yaml
</code></pre><p><code>express</code> の中には <code>node_modules</code> がないのでしょうか。 <code>express</code> の依存のすべてはどこにあるのでしょうか。</p><p><code>express</code> がただのシンボリックリンクであるというところに仕掛けがあります。 Node.js は依存解決をする際に、シンボリックリンクであるかに関わらず、実際のパスを使います。 しかし、今気にしている <code>express</code> の本当の場所はどこなのでしょうか。</p><p>それがここになります: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules/.pnpm/express@4.17.1/node_modules/express</a></p><p>これで、<code>.pnpm/</code> フォルダの役割もわかりましたね。 <code>.pnpm/</code> はすべての依存パッケージをフラットなフォルダー構成にして保存し、各依存は次のような命名規則に従ったフォルダに格納されています。</p><pre><code class="language-text">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;
</code></pre><p>このディレクトリを仮想ストアと呼んでいます。</p><p>フラットは構造によって、npm v2 によるネストされた <code>node_modules</code> での、パス名が長くなりすぎる問題を解決し、さらに npm v3,4,5,6 や Yarn v1 が生成するフラットな <code>node_modules</code> とは違い、依存パッケージをそれぞれ独立させています。</p><p>今度は本物の <code>express</code> の中身を見てみましょう。</p><pre><code class="language-text">  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>これは騙されているんでしょうか？ <code>node_modules</code> はやはりありません！ pnpm の <code>node_modules</code> に対する第二の仕掛けは、パッケージの依存は、それ自身と同じ階層に置かれている点にあります。 <code>express</code> の依存は <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code> ではなく <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm/express@4.17.1/node_modules/</a> にあります。</p><pre><code class="language-text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
</code></pre><p><code>express</code> の依存のすべてはシンボリックリンクであり、それらは <code>node_modules/.pnpm/</code> 内の適切な場所へとリンクされています。 <code>express</code> の依存は1つ上の階層に置くことで、循環したシンボリックリンクになることを回避しています。</p><p>見て分かる通り、pnpm の <code>node_modules</code> の構造は最初は珍しく思えましたが、</p><ol><li>その構造は完全に Node.js 互換なものであり、</li><li>パッケージはその依存とともに適切にグループ化されいます。</li></ol><p>peer dependency がある場合は、構造は <a href="/how-peers-are-resolved">もう少し複雑</a> にはなりますが、それでも考え方は同じです：フラットなディレクトリ構造を利用して、シンボリックリンクによりネストされた構造を生成します。</p>]]></content:encoded>
        </item>
    </channel>
</rss>