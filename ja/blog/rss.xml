<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>pnpm Blog</title>
        <link>https://pnpm.io/ja/blog</link>
        <description>pnpm Blog</description>
        <lastBuildDate>Wed, 29 Dec 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[2021年のpnpm]]></title>
            <link>https://pnpm.io/ja/blog/2021/12/29/yearly-update</link>
            <guid>/2021/12/29/yearly-update</guid>
            <pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[今年はpnpmにとって良い年でした。年末なので、1年を振り返ってみましょう]]></description>
            <content:encoded><![CDATA[<p>今年はpnpmにとって良い年でした。年末なので、1年を振り返ってみましょう</p><h2>使い方</h2><h3>ダウンロード数</h3><p>今年の目標は、ダウンロード数でBowerに勝つことでした。 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29">11月に</a>この目標を達成することができました。</p><p><img src="/img/blog/pnpm-vs-bower-stats.png"/></p><p>pnpmは 2021年に 2020年の 約 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29">3倍</a> ダウンロードされました。</p><p><img src="/img/blog/download-stats-2021.png"/></p><p>:::note</p><p>この統計は、pnpmの全てのインストール方法を測定しているわけではありません。 <a href="https://www.npmjs.com/package/pnpm">pnpm npm package</a>ダウンロード数のみを測定しています。 今年追加したpnpmのコンパイル済みバイナリバージョンは別で配布されます。</p><p>:::</p><h3>ドキュメントの訪問者数</h3><p>私たちはGoogle Analyticsを使って、ドキュメントサイトから個人を特定できない統計情報を収集しています。 2021年には、1週間に2,000人以上のユニークビジターが訪れることもありました。</p><p><img src="/img/blog/ga-unique-visits-2021.png"/></p><p>利用者の大半はアメリカか中国からアクセスしています</p><p><img src="/img/blog/countries-2021.png"/></p><h3>GitHubのスター数</h3><p><a href="https://github.com/pnpm/pnpm">メインのGitHubリポジトリ</a>は、今年だけで5000以上のスターを獲得しました</p><p><img src="/img/blog/stars-2021.png"/></p><h3>新規ユーザー</h3><p>今年最大の新規ユーザーは、<a href="https://github.com/pnpm/pnpm.github.io/pull/89">Bytedance</a> (TikTok運営元の会社)です</p><p>また、多くの素晴らしいオープンソースプロジェクトがpnpmを使用するようになりました。 スイッチした理由として、pnpmがモノレポを強力にサポートしていることを挙げるプロジェクトがあります</p><ul><li><a href="https://github.com/vuejs/vue-next">Vue</a></li><li><a href="https://github.com/vitejs/vite">Vite</a></li><li><a href="https://pnpm.io/workspaces#usage-examples">その他多数</a></li></ul><p>pnpmの効率、スピード、美しさが気に入って乗り換えたプロジェクトもあります</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419">Browserslist</a></li></ul><h2>機能のハイライト</h2><h3>新しいlockfileの形式(<a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0">v6.0.0</a>から)</h3><p>今年最初の、そして最も重要な変更点の1つは、新しい<code>pnpm-lock.yaml</code>形式でした。 これは破壊的変更だったので、v6をリリースする必要がありました。 しかし、これは成功でした。 いままでのlockfileでは、Gitのコンフリクトが頻繁に発生していました。 新しい形式を導入して以来、Gitのコンフリクトに関する苦情は一切なくなりました。</p><h3>Node.jsのバージョン管理 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0">v6.12.0</a>から)</h3><p>Node.jsのバージョンを管理するコマンド(<code>pnpm env</code>)を追加しました。 そのため、nvmやVoltaのようなNode.jsのバージョン管理ソフトの代わりに、pnpmを使えます。</p><p>また、pnpmはスタンドアロンの実行可能ファイルとして出荷されますので、Node.jsがプリインストールされていないシステムでも実行することができます。</p><h3>ローカル依存性の注入 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0">v6.20.0</a>から)</h3><p>ローカル依存関係を &quot;注入&quot; することができます。 デフォルトでは、ローカルな依存関係は <code>node_modules</code>にシンボリックリンクされますが、この新しい機能では、代わりにパッケージのファイルをハードリンクするように pnpm に指示することができます。</p><h3>peerDependency issueのレポート機能の改善 (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0">v6.24.0</a>)</h3><p>peerDependenciesの問題は、以前はプレーンテキストで出力され、理解するのが困難でした。 現在は、すべてグループ化され、美しい階層構造で出力されます。</p><h2>競合ツールの動向</h2><h3>Yarn</h3><p>Yarnは<a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-">v3.1</a>からpnpmリンカを追加しました。 そのため、Yarnはpnpmが作成するものと同様のディレクトリ構造をもつnode_modulesを作成できます。</p><p>また、Yarnチームは、ディスク容量を効率的に使用できるように、コンテンツ・アドレス可能なストレージを実装する予定です。</p><h3>npm</h3><p>npmチームは、pnpmが採用しているシンボリックリンクによるnode_modulesのディレクトリ構造も採用することに決定しました。(関連する <a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md">RFC</a>).</p><h3>その他</h3><p>Zigで書かれた<a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1">Bun</a>と Rustで書かれた<a href="https://github.com/voltpkg/volt">Volt</a> のふたつは、npm/Yarn/pnpm より高速と主張しています。 私はこれらの新しいパッケージマネージャーのベンチマークはまだ行っていません。</p><h2>今後の計画</h2><p>より速く、より良く、ベストを目指す</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pnpm でのノードモジュールに関するオプション設定]]></title>
            <link>https://pnpm.io/ja/blog/2020/10/17/node-modules-configuration-options-with-pnpm</link>
            <guid>/2020/10/17/node-modules-configuration-options-with-pnpm</guid>
            <pubDate>Sat, 17 Oct 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[nodemodules ディレクトリを生成する方法は多くあります。 ゆるい nodemodules を作成する方法もありますが、ここでの目標は最も厳格なものを生成することです。]]></description>
            <content:encoded><![CDATA[<p>node_modules ディレクトリを生成する方法は多くあります。 ゆるい node_modules を作成する方法もありますが、ここでの目標は最も厳格なものを生成することです。</p><h2>デフォルトの構築方法</h2><p>デフォルトでは、pnpm v5 は準厳格な node_modules を作成します。 準厳格な場合は、アプリケーションからは<code>package.json</code> に依存として追加されているパッケージのみを require できます。(いくつかの例外を除きます。) ただし、依存関係はどのパッケージにもアクセスすることができます。</p><p>デフォルトの設定は以下のようになります:</p><pre><code class="language-ini">; すべてのパッケージを node_modules/.pnpm/node_modules に巻き上げる
hoist-pattern[]=*

; TypeScript でうまく扱えるように、すべての型定義をルートに巻き上げる
public-hoist-pattern[]=*types*

; すべての ESLint に関係するパッケージをルートに巻き上げる
public-hoist-pattern[]=*eslint*
</code></pre><h2>プラグ・アンド・プレイ。 最も厳格な設定</h2><p>pnpm は v5.9 から <a href="https://yarnpkg.com/features/pnp">Yarn の プラグ・アンド・プレイ</a> をサポートしています。 プラグ・アンド・プレイでは、アプリケーションも、その依存も、宣言された依存にのみアクセスできるようになります。 この設定は <code>hoist=false</code> を設定するよりもさらに厳格です。モノレポの中では、アプリケーションはたとえルートの依存にすらアクセスできないからです。</p><p>プラグ・アンド・プレイを使用するには、次の設定を使用してください。</p><pre><code class="language-ini">node-linker=pnp
symlink=false
</code></pre><h2>厳格で伝統的なモジュールディレクトリの構造</h2><p>まだプラグ・アンド・プレイを使用する準備ができていない場合でも、hoist を false に設定することにより、パッケージが自身の依存にのみアクセスできるようにすることが可能です。</p><pre><code class="language-ini">hoist=false
</code></pre><p>しかし、いくつかの依存が、その依存にないパッケージへのアクセスを試みようとする場合は、2つの方法があります。</p><ol><li><p><code>pnpmfile.js</code> を作成して、<a href="/pnpmfile">hook</a> を使用して不足している依存をパッケージのマニフェストに加える。</p></li><li><p><code>hoist-pattern</code> 設定にパターンを追加する。 例えば、見つからないモジュールが <code>babel-core</code> の場合は、次の設定を <code>.npmrc</code> に追記します。</p><pre><code class="language-ini">hoist-pattern[]=babel-core
</code></pre></li></ol><h2>最も悪いケース - ルートへの巻き上げ</h2><p>一部のツールは、すべてを仮想ストアのルートに、一部のパッケージをルートに巻き上げる pnpm のデフォルト設定でも機能しない場合があります。 この場合、依存のすべて、または一部をモジュールディレクトリのルートに引き上げることができます。</p><p>node_modules のルートにすべてを巻き上げる場合:</p><pre><code class="language-ini">shamefully-hoist=true
</code></pre><p>パターンにマッチしたパッケージのみを巻き上げる場合:</p><pre><code class="language-ini">public-hoist-pattern[]=babel-*
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[フラットな node_modules が唯一の方法ではありません]]></title>
            <link>https://pnpm.io/ja/blog/2020/05/27/flat-node-modules-is-not-the-only-way</link>
            <guid>/2020/05/27/flat-node-modules-is-not-the-only-way</guid>
            <pubDate>Wed, 27 May 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[pnpm の新規ユーザーから、pnpm が生成する node_modules の奇妙な構造についてよく聞かれます。 なぜ平坦な構造を使用しないのでしょうか。 依存のさらにその依存はどこにあるのでしょうか。]]></description>
            <content:encoded><![CDATA[<p>pnpm の新規ユーザーから、pnpm が生成する <code>node_modules</code> の奇妙な構造についてよく聞かれます。 なぜ平坦な構造を使用しないのでしょうか。 依存のさらにその依存はどこにあるのでしょうか。</p><blockquote><p>この記事では、npm や Yarn の生成するフラットな <code>node_modules</code> に馴染みのある読者を想定しています。 npm が v3 からフラットな <code>node_modules</code> を採用する必要があった理由については、 <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">なぜ pnpm が必要なのでしょうか (英語)</a> を参照してください。</p></blockquote><p>では、なぜ pnpm は通常とは異なる構造の <code>node_modules</code> を使用するのでしょう。 試しに 2 つのディレクトリを作成して、片方には <code>npm add express</code> を、もう一方には <code>pnpm add express</code> を実行してみてください。 npm の方のディレクトリにある <code>node_modules</code> は次のようになります。</p><pre><code class="language-text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express
</code></pre><p><a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">こちら</a> でディレクトリ全体を確認できます。</p><p>そして、こちらが pnpm が生成する <code>node_modules</code> は次のようになります。</p><pre><code class="language-text">.pnpm
.modules.yaml
express
</code></pre><p><a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">こちら</a> からディレクトリ全体を確認できます。</p><p>依存のすべてはどこにあるのでしょうか。 <code>node_modules</code> 配下には、フォルダは <code>.pnpm</code> のみが存在し、あとは <code>express</code> という名前のシンボリックリンクです。 今回、 <code>express</code> しかインストールしていないため、アプリケーションからアクセスできるパッケージはこれのみなのです。</p><blockquote><p>pnpm のこの厳格さがどうしていいのか、ということにういては <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">こちら</a> を参照してください。</p></blockquote><p><code>express</code> の中身がどうなっているか確認してみましょう。</p><pre><code class="language-text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
    .modules.yaml
</code></pre><p><code>express</code> の中には <code>node_modules</code> がないのでしょうか。 <code>express</code> の依存のすべてはどこにあるのでしょうか。</p><p><code>express</code> がただのシンボリックリンクであるというところに仕掛けがあります。 Node.js は依存解決をする際に、シンボリックリンクであるかに関わらず、実際のパスを使います。 しかし、今気にしている <code>express</code> の本当の場所はどこなのでしょうか。</p><p>それがここになります: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules/.pnpm/express@4.17.1/node_modules/express</a></p><p>これで、<code>.pnpm/</code> フォルダの役割もわかりましたね。 <code>.pnpm/</code> はすべての依存パッケージをフラットなフォルダー構成にして保存し、各依存は次のような命名規則に従ったフォルダに格納されています。</p><pre><code class="language-text">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;
</code></pre><p>このディレクトリを仮想ストアと呼んでいます。</p><p>フラットは構造によって、npm v2 によるネストされた <code>node_modules</code> での、パス名が長くなりすぎる問題を解決し、さらに npm v3,4,5,6 や Yarn v1 が生成するフラットな <code>node_modules</code> とは違い、依存パッケージをそれぞれ独立させています。</p><p>今度は本物の <code>express</code> の中身を見てみましょう。</p><pre><code class="language-text">  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>これは騙されているんでしょうか？ <code>node_modules</code> はやはりありません！ pnpm の <code>node_modules</code> に対する第二の仕掛けは、パッケージの依存は、それ自身と同じ階層に置かれている点にあります。 <code>express</code> の依存は <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code> ではなく <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm/express@4.17.1/node_modules/</a> にあります。</p><pre><code class="language-text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
</code></pre><p><code>express</code> の依存のすべてはシンボリックリンクであり、それらは <code>node_modules/.pnpm/</code> 内の適切な場所へとリンクされています。 <code>express</code> の依存は1つ上の階層に置くことで、循環したシンボリックリンクになることを回避しています。</p><p>見て分かる通り、pnpm の <code>node_modules</code> の構造は最初は珍しく思えましたが、</p><ol><li>その構造は完全に Node.js 互換なものであり、</li><li>パッケージはその依存とともに適切にグループ化されいます。</li></ol><p>peer dependency がある場合は、構造は <a href="/how-peers-are-resolved">もう少し複雑</a> にはなりますが、それでも考え方は同じです：フラットなディレクトリ構造を利用して、シンボリックリンクによりネストされた構造を生成します。</p>]]></content:encoded>
        </item>
    </channel>
</rss>