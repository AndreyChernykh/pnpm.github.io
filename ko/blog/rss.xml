<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>pnpm Blog</title>
        <link>https://pnpm.io/ko/blog</link>
        <description>pnpm Blog</description>
        <lastBuildDate>Wed, 29 Dec 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[pnpm의 2021년]]></title>
            <link>https://pnpm.io/ko/blog/2021/12/29/yearly-update</link>
            <guid>/2021/12/29/yearly-update</guid>
            <pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[올해의 끝자락이고 pnpm에게는 좋은 한 해였습니다. 그러니, 어떻게 되었는지 봅시다.]]></description>
            <content:encoded><![CDATA[<p>올해의 끝자락이고 pnpm에게는 좋은 한 해였습니다. 그러니, 어떻게 되었는지 봅시다.</p><h2>사용량</h2><h3>다운로드 통계</h3><p>올해 저의 목표는 다운로드 수에서 Bower를 이기는 것이 었습니다. 우리는 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29">11월</a>에 그 목표를 달성할 수 있었습니다.</p><p><img src="/img/blog/pnpm-vs-bower-stats.png"/></p><p>pnpm은 2020년에 비해 2021년에는 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29">약 3배 더 많이</a> 다운로드되었습니다.</p><p><img src="/img/blog/download-stats-2021.png"/></p><p>:::참고</p><p>이 통계는 pnpm이 설치될 수 있는 모든 다양한 방법을 측정하지도 않습니다! 그들은 단지 <a href="https://www.npmjs.com/package/pnpm">pnpm npm 패키지</a>의 다운로드만 측정합니다. 올해 우리는 또한 pnpm의 컴파일 된 바이너리 버전을 추가하며 이는 다른식으로 출하됩니다.</p><p>:::</p><h3>문서 방문</h3><p>Google Analytics를 사용하여 문서에서 개인화되지 않은 통계를 수집합니다. 2021년에는 때때로 일주일에 2,000명 이상의 고유 방문자가 있었습니다.</p><p><img src="/img/blog/ga-unique-visits-2021.png"/></p><p>대부분의 사용자는 미국과 중국 출신입니다.</p><p><img src="/img/blog/countries-2021.png"/></p><h3>깃허브 스타</h3><p><a href="https://github.com/pnpm/pnpm">주요 GitHub 저장소</a>는 올해 +5,000개의 별을 받았습니다.</p><p><img src="/img/blog/stars-2021.png"/></p><h3>신규 사용자</h3><p>올해 가장 큰 신규 사용자는 <a href="https://github.com/pnpm/pnpm.github.io/pull/89">Bytedance</a> (TikTok 뒤에 있는 회사)입니다.</p><p>또한 많은 훌륭한 오픈 소스 프로젝트에서 pnpm을 사용하기 시작했습니다. 일부는 모노레포에 대한 뛰어난 지원 때문에 pnpm으로 전환했습니다.</p><ul><li><a href="https://github.com/vuejs/vue-next">Vue</a></li><li><a href="https://github.com/vitejs/vite">Vite</a></li><li>및 <a href="https://pnpm.io/workspaces#usage-examples">다른 것들</a></li></ul><p>일부는 pnpm이 얼마나 효율적이고 빠르며 아름다운지를 좋아하기 때문에 전환했습니다.</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419">Browserslist</a></li></ul><h2>주요 기능</h2><h3>새로운 locfile 형식 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0">v6.0.0</a> 이후)</h3><p>올해 처음이자 가장 중요한 변경 사항 중 하나는 새로운 <code>pnpm-lock.yaml</code> 형식입니다. 이것은 브레이킹 체인지였기 때문에 v6을 출시해야 했습니다. 그러나 그것은 성공적이었습니다. 이전 lockfile은 Git 충돌을 자주 일으켰습니다. 새로운 형식이 도입된 이후로 Git 충돌에 대한 불만은 접수되지 않았습니다.</p><h3>Node.js 버전 관리 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0">v6.12.0</a> 이후)</h3><p>Node.js 버전을 관리할 수 있는 새로운 명령어 (<code>pnpm env</code>)를 출하했습니다. 따라서 nvm 또는 Volta와 같은 Node.js 버전 관리자 대신 pnpm을 사용할 수 있습니다.</p><p>또한 pnpm은 독립 실행형 실행 파일로 제공되므로 시스템에 Node.js가 사전 설치되어 있지 않아도 실행할 수 있습니다.</p><h3>로컬 의존성 주입 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0">v6.20.0</a> 이후)</h3><p>여러분은 로컬 의존성을 &quot;주입&quot;할 수 있습니다. 기본적으로 로컬 의존성은 <code>node_modules</code>에 심볼릭 링크되지만 이 새로운 기능을 사용하면 pnpm에 패키지 파일을 하드 링크하도록 지시할 수 있습니다.</p><h3>피어 의존성 문제에 대한 보고 기능 개선 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0">v6.24.0</a> 이후)</h3><p>피어 의존성 문제는 일반 텍스트로 출력되어 이해하기 어려웠습니다. 이제 모두 그룹화되어 멋진 계층 구조로 출력됩니다.</p><h2>경쟁</h2><h3>Yarn</h3><p>Yarn은 <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-">v3.1</a>에서 pnpm 링커를 추가했습니다. 따라서 Yarn은 pnpm이 생성하는 것과 유사한 노드 모듈 디렉토리 구조를 생성할 수 있습니다.</p><p>또한 Yarn 팀은 디스크 공간 효율성을 높이기 위해 콘텐츠 주소 지정 가능 스토리지를 구현할 계획입니다.</p><h3>npm</h3><p>npm 팀은 pnpm이 사용하는 심볼릭 링크된 node-modules 디렉토리 구조 (<a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md">RFC</a>와 관련된)도 채택하기로 결정했습니다.</p><h3>기타</h3><p>Zig로 작성된 <a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1">Bun</a>과 Rust로 작성된 <a href="https://github.com/voltpkg/volt">Volt</a> 모두 npm/Yarn/pnpm보다 빠르다고 주장합니다. 이 새로운 패키지 관리자를 아직 벤치마킹하지 않았습니다.</p><h2>향후 계획</h2><p>더 빠르고, 더 좋고, 최고가 될 것 입니다.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pnpm을 사용한 노드 모듈 구성 옵션]]></title>
            <link>https://pnpm.io/ko/blog/2020/10/17/node-modules-configuration-options-with-pnpm</link>
            <guid>/2020/10/17/node-modules-configuration-options-with-pnpm</guid>
            <pubDate>Sat, 17 Oct 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[nodemodules 디렉토리를 만드는 방법에는 여러 가지가 있습니다. 여러분의 목표는 가장 엄격한 것을 만드는 것이지만 그것이 가능하지 않다면, 느슨한 nodemodules을 만드는 옵션도 있습니다.]]></description>
            <content:encoded><![CDATA[<p>node_modules 디렉토리를 만드는 방법에는 여러 가지가 있습니다. 여러분의 목표는 가장 엄격한 것을 만드는 것이지만 그것이 가능하지 않다면, 느슨한 node_modules을 만드는 옵션도 있습니다.</p><h2>기본 설정</h2><p>기본적으로 pnpm v5는 반만 엄격한 node_modules를 만듭니다. 반만 엄격하다는 것은 응용 프로그램이 <code>package.json</code>에 의존성으로 추가된 패키지만 요구할 수 있음을 의미합니다 (몇 가지 예외는 제외). 그러나 여러분의 의존성은 모든 패키지에 접근할 수 있습니다.</p><p>기본 구성은 다음과 같습니다.</p><pre><code class="language-ini">; 모든 패키지는  node_modules/.pnpm/node_modules에 호이스팅되어 있습니다
hoist-pattern[]=*

; 모든 타입은 타입스크립트를 행복하게 만들기 위해 루트로 호이스팅되어 있습니다
public-hoist-pattern[]=*types*

; 모든 ESLint와 관련된 패키지는 마찬가지로 호이스팅 되어 있습니다
public-hoist-pattern[]=*eslint*
</code></pre><h2>Plug&#x27;n&#x27;Play. 가장 엄격한 구성</h2><p>pnpm은 v5.9 부터 <a href="https://yarnpkg.com/features/pnp">Yarn의 Plug&#x27;n &#x27; Play</a> 를 지원합니다. PnP를 사용하면 애플리케이션과 애플리케이션의 의존성이 선언된 의존성에만 접근할 수 있습니다. 이것은 monorepo 내부에서 애플리케이션이 루트 프로젝트의 의존성에도 접근할 수 없기 때문에 <code>hoist=false</code> 로 설정하는 것보다 훨씬 더 엄격합니다.</p><p>Plug&#x27;n&#x27;Play를 사용하려면 다음 설정을 설정하세요.</p><pre><code class="language-ini">node-linker=pnp
symlink=false
</code></pre><h2>엄격하고 전통적인 모듈 디렉토리</h2><p>아직 PnP를 사용할 준비가 되지 않은 경우에도 여전히 엄격할 수 있으며 호이스팅 구성을 false로 설정하여 패키지가 자체 의존성에만 접근하도록 허용할 수 있습니다.</p><pre><code class="language-ini">hoist=false
</code></pre><p>그러나 의존성 중 일부가 그들의 의존성에 없는 패키지에 접근하려고 하는 경우 두 가지 옵션이 있습니다.</p><ol><li><p><code>pnpmfile.js</code>를 만들고 <a href="/pnpmfile">hook</a>를 사용하여 패키지의 매니페스트에 누락된 의존성을 추가합니다.</p></li><li><p><code>hoist-pattern</code> 설정에 패턴을 추가합니다. 예를 들어, 그 찾을 수 없는 모듈이 <code>babel-core</code>이면, 다음 설정을 <code>.npmrc</code>추가합니다.</p><pre><code class="language-ini">hoist-pattern[]=babel-core
</code></pre></li></ol><h2>최악의 경우 - 루트로 호이스팅</h2><p>일부 도구는 모든 것을 가상 저장소의 루트에 호이스팅하고 일부 패키지를 루트에 호이스팅하는 pnpm의 기본 구성에서도 작동하지 않을 수 있습니다. 이 경우, 모든 항목 또는 의존성의 하위 집합을 모듈 디렉터리의 루트로 호이스팅할 수 있습니다.</p><p>모든 항목을 node_modules의 루트로 호이스팅하기:</p><pre><code class="language-ini">shamefully-hoist=true
</code></pre><p>패턴과 일치하는 패키지만 호이스팅하기:</p><pre><code class="language-ini">public-hoist-pattern[]=babel-*
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[평탄한 node_modules가 유일한 방법은 아닙니다.]]></title>
            <link>https://pnpm.io/ko/blog/2020/05/27/flat-node-modules-is-not-the-only-way</link>
            <guid>/2020/05/27/flat-node-modules-is-not-the-only-way</guid>
            <pubDate>Wed, 27 May 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[pnpm의 신규 사용자들이 pnpm에서 생성하는 node_modules의 특이한 구조에 대해 자주 질문합니다. 왜 플랫이 아닌가요? 모든 하위 의존성들은 어디에 있나요?]]></description>
            <content:encoded><![CDATA[<p>pnpm의 신규 사용자들이 pnpm에서 생성하는 <code>node_modules</code>의 특이한 구조에 대해 자주 질문합니다. 왜 플랫이 아닌가요? 모든 하위 의존성들은 어디에 있나요?</p><blockquote><p>저는 이 기사의 독자들이 npm과 Yarn에서 생성하는 <code>node_modules</code>에 이미 익숙하다고 가정합니다. 만약 npm 3이 플랫 <code>node_modules</code> 를 사용하여 v3 에서 시작해야 하는 이유를 이해하지 못하는 경우, <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">에서 몇 가지 사전 히스토리를 찾을 수 있습니다.</a>.</p></blockquote><p>그러면 왜 pnpm의 <code>node_modules</code> 디렉토리는 특이할까요? 두 개의 디렉토리를 만들고 그 중 하나에서 <code>npm add express</code> 을 실행하고 다른 하나에서 <code>pnpm add express</code>을 실행합니다. 다음은 첫 번째 디렉토리의 <code>node_modules</code>에서 얻을 수 있는 상위 항목입니다.</p><pre><code class="language-text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express
</code></pre><p>여러분은 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">여기</a>에서 전체 디렉토리를 볼 수 있습니다.</p><p>그리고 이것이 pnpm에 의해 만들어진 <code>node_modules</code>에서 얻은 항목입니다.</p><pre><code class="language-text">.pnpm
.modules.yaml
express
</code></pre><p>여러분은 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">여기</a>에서 전체 디렉토리를 확인할 수 있습니다.</p><p>그래서 모든 의존성들은 어디에 있을까요? <code>node_modules</code> 에는 <code>.pnpm</code> 이라는 하나의 폴더뿐이며 <code>express</code>라는 심볼릭 링크만 있습니다. 음, 우리는 오직 <code>express</code>만 설치했으므로 당신의 애플리케이션이 접근할 수 있는 유일한 패키지입니다.</p><blockquote><p>왜 pnpm의 엄격함이 좋은지 <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">여기</a>서 자세히 읽어보세요.</p></blockquote><p><code>express</code>안에 무엇이 있는지 봅시다.</p><pre><code class="language-text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
    .modules.yaml
</code></pre><p><code>express</code> 에는 <code>node_modules</code>가 없네요? <code>express</code>의 모든 의존성들은 어디에 있을까요?</p><p>트릭은 <code>express</code>가 단지 심볼릭 링크라는 것입니다. Node.js는 의존성을 해결할 때, 실제 위치를 사용하므로 심볼릭 링크를 유지하지 않습니다. 하지만 <code>express</code>의 실제 위치가 어디냐고 당신은 물어볼 수 있겠죠?</p><p>여기: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules/.pnpm/express@4.17.1/node_modules/express</a>.</p><p>자, 이제 우리는 <code>.pnpm/</code> 폴더의 목적을 알고 있습니다. <code>.pnpm/</code> 는 모든 패키지를 플랫 폴더 구조로 저장하므로 모든 패키지는 다음 패턴으로 이름이 지정된 폴더에서 찾을 수 있습니다.</p><pre><code class="language-text">.pnpm/&lt;이름&gt;@&lt;버전&gt;/node_modules/&lt;이름&gt;
</code></pre><p>우리는 이것을 가상 저장소 디렉토리라고 부릅니다.</p><p>이러한 평탄한 구조는 npm v2에 의해 만들어진 중첩 형식의 <code>node_modules </code> 에서의 긴 경로 문제를 회피하지만, npm v3,4,5,6 또는 Yarn v1에 의해 생성된 평탄한 <code>node _modules</code>와는 달리 패키지를 격리된 상태로 유지합니다.</p><p>이제 <code>express</code>의 실제 위치를 알아보겠습니다.</p><pre><code class="language-text">  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>사기일까요? <code>node _modules</code>가 여전히 없네요! pnpm에서 <code>node_modules</code> 구조의 두 번째 트릭은 패키지의 의존성들이 의존 패키지의 실제 위치와 동일한 디렉토리 레벨에 있다는 것입니다. 따라서 <code>express</code>의 의존성들은 <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code>에 있는 것이 아니라 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm/express@4.17.1/node_modules/</a>에 있습니다:</p><pre><code class="language-text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
</code></pre><p><code>express</code>의 모든 의존성들은 <code>node_modules/.pnpm/</code> 내의 적절한 디렉토리에 대한 심볼릭 링크입니다. <code>express</code>의 의존성들을 한 단계 위로 배치하면 순환 심볼릭 링크를 피할 수 있습니다.</p><p>보시다시피 pnpm의 <code>node_modules</code> 구조가 처음에는 특이한 것 같죠:</p><ol><li>Node.js와 완전히 호환됩니다.</li><li>패키지는 의존성과 함께 멋지게 그룹화됩니다.</li></ol><p>피어 의존성을 가진 패키지의 경우 구조가 <a href="/how-peers-are-resolved">조금 더 복잡</a>하지만 생각은 동일합니다: 평탄한 디렉토리 구조로 중첩구조를 만들기 위해 심볼릭 링크를 사용하기</p>]]></content:encoded>
        </item>
    </channel>
</rss>