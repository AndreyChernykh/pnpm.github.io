<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>pnpm Blog</title>
        <link>https://pnpm.io/pt/blog</link>
        <description>pnpm Blog</description>
        <lastBuildDate>Wed, 29 Dec 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[The year 2021 for pnpm]]></title>
            <link>https://pnpm.io/pt/blog/2021/12/29/yearly-update</link>
            <guid>/2021/12/29/yearly-update</guid>
            <pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[It is the end of the year and it was a good year for pnpm, so let's see how it went.]]></description>
            <content:encoded><![CDATA[<p>It is the end of the year and it was a good year for pnpm, so let&#x27;s see how it went.</p><h2>Usage</h2><h3>Download Stats</h3><p>My goal this year was to beat Bower by the number of downloads. We were able to achieve this goal <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29">in November</a>:</p><p><img src="/img/blog/pnpm-vs-bower-stats.png"/></p><p>pnpm was downloaded about <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29">3 times more</a> in 2021 than in 2020:</p><p><img src="/img/blog/download-stats-2021.png"/></p><p>:::note</p><p>These stats don&#x27;t even measure all the different ways that pnpm may be installed! They only measure the downloads of the <a href="https://www.npmjs.com/package/pnpm">pnpm npm package</a>. This year we also added compiled binary versions of pnpm, which are shipped differently.</p><p>:::</p><h3>Docs visits</h3><p>We collect some unpersonalized stats from our docs using Google Analytics. In 2021, sometimes we had more than 2,000 unique visitors a week.</p><p><img src="/img/blog/ga-unique-visits-2021.png"/></p><p>Most of our users are from the United States and China.</p><p><img src="/img/blog/countries-2021.png"/></p><h3>GitHub stars</h3><p>Our <a href="https://github.com/pnpm/pnpm">main GitHub repository</a> received +5,000 stars this year.</p><p><img src="/img/blog/stars-2021.png"/></p><h3>New users</h3><p>Our biggest new user this year is <a href="https://github.com/pnpm/pnpm.github.io/pull/89">Bytedance</a> (the company behind TikTok).</p><p>Also, many great open-source projects started to use pnpm. Some switched to pnpm because of its great support of monorepos:</p><ul><li><a href="https://github.com/vuejs/vue-next">Vue</a></li><li><a href="https://github.com/vitejs/vite">Vite</a></li><li>and <a href="https://pnpm.io/workspaces#usage-examples">others</a></li></ul><p>Some switched because they like how efficient, fast, and beautiful pnpm is:</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419">Browserslist</a></li></ul><h2>Feature Highlights</h2><h3>New lockfile format (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0">v6.0.0</a>)</h3><p>One of the first and most important changes this year was the new <code>pnpm-lock.yaml</code> format. This was a breaking change, so we had to release v6. But it was a success. The old lockfile was causing Git conflicts frequently. Since the new format was introduced, we did not receive any complaints about Git conflicts.</p><h3>Managing Node.js versions (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0">v6.12.0</a>)</h3><p>We shipped a new command (<code>pnpm env</code>) that allows to manage Node.js versions. So you may use pnpm instead of Node.js version managers like nvm or Volta.</p><p>Also, pnpm is shipped as a standalone executable, so you can run it even with no Node.js preinstalled on the system.</p><h3>Injecting local dependencies (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0">v6.20.0</a>)</h3><p>You may &quot;inject&quot; a local dependency. By default, local dependencies are symlinked to <code>node_modules</code> but with this new feature you may instruct pnpm to hard link the files of the package instead.</p><h3>Improved reporting of peer dependency issues (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0">v6.24.0</a>)</h3><p>Peer dependency issues used to be printed as plain text and it was hard to understand them. They are now all grouped and printed in a nice hierarchy structure.</p><h2>The Competition</h2><h3>Yarn</h3><p>Yarn added a pnpm linker in <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-">v3.1</a>. So Yarn can create a similar node-modules directory structure to the one that pnpm creates.</p><p>Also, the Yarn team plans to implement a content-addressable storage to be more disk space efficient.</p><h3>npm</h3><p>The npm team decided to also adopt the symlinked node-modules directory structure that pnpm uses (related <a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md">RFC</a>).</p><h3>Others</h3><p><a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1">Bun</a> written in Zig and <a href="https://github.com/voltpkg/volt">Volt</a> written in Rust both claim to be faster than npm/Yarn/pnpm. I did not benchmark these new package managers yet.</p><h2>Future Plans</h2><p>Faster, better, best.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Node-Modules configuration options with pnpm]]></title>
            <link>https://pnpm.io/pt/blog/2020/10/17/node-modules-configuration-options-with-pnpm</link>
            <guid>/2020/10/17/node-modules-configuration-options-with-pnpm</guid>
            <pubDate>Sat, 17 Oct 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[There are many ways to create a nodemodules directory. Your goal must be to create the most strict one but if that is not possible, there are options to make a loose nodemodules as well.]]></description>
            <content:encoded><![CDATA[<p>There are many ways to create a node_modules directory. Your goal must be to create the most strict one but if that is not possible, there are options to make a loose node_modules as well.</p><h2>The default setup</h2><p>By default, pnpm v5 will create a semi-strict node_modules. Semi-strict means that your application will only be able to require packages that are added as dependencies to <code>package.json</code> (with a few exceptions). However, your dependencies will be able to access any packages.</p><p>The default configuration looks like this:</p><pre><code class="language-ini">; All packages are hoisted to node_modules/.pnpm/node_modules
hoist-pattern[]=*

; All types are hoisted to the root in order to make TypeScript happy
public-hoist-pattern[]=*types*

; All ESLint-related packages are hoisted to the root as well
public-hoist-pattern[]=*eslint*
</code></pre><h2>Plug&#x27;n&#x27;Play. The strictest configuration</h2><p>pnpm supports <a href="https://yarnpkg.com/features/pnp">Yarn&#x27;s Plug&#x27;n&#x27;Play</a> since v5.9. With PnP, both your application and the dependencies of your application will have access only to their declared dependencies. This is even stricter then setting <code>hoist=false</code> because inside a monorepo, you&#x27;re application will not be able to access even the dependencies of the root project.</p><p>To use Plug&#x27;n&#x27;Play, set these settings:</p><pre><code class="language-ini">node-linker=pnp
symlink=false
</code></pre><h2>A strict, traditional modules directory</h2><p>If you are not ready to use PnP yet, you can still be strict and only allow packages to access their own dependencies by setting the hoist configuration to false:</p><pre><code class="language-ini">hoist=false
</code></pre><p>However, if some of your dependencies are trying to access packages that they don&#x27;t have in dependencies, you have two options:</p><ol><li><p>Create a <code>pnpmfile.js</code> and use a <a href="/pnpmfile">hook</a> to add the missing dependency to the package&#x27;s manifest.</p></li><li><p>Add a pattern to the <code>hoist-pattern</code> setting. For instance, if the not found module is <code>babel-core</code>, add the following setting to <code>.npmrc</code>:</p><pre><code class="language-ini">hoist-pattern[]=babel-core
</code></pre></li></ol><h2>The worst case - hoisting to the root</h2><p>Some tools might not work even with the default configuration of pnpm, which hoists everything to the root of the virtual store and some packages to the root. In this case, you can hoist either everything or a subset of dependencies to the root of the modules directory.</p><p>Hoisting everything to the the root of node_modules:</p><pre><code class="language-ini">shamefully-hoist=true
</code></pre><p>Hoisting only packages that match a pattern:</p><pre><code class="language-ini">public-hoist-pattern[]=babel-*
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[node_modules planos não são a única maneira]]></title>
            <link>https://pnpm.io/pt/blog/2020/05/27/flat-node-modules-is-not-the-only-way</link>
            <guid>/2020/05/27/flat-node-modules-is-not-the-only-way</guid>
            <pubDate>Wed, 27 May 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[Novos usuários do pnpm frequentemente me perguntam acerca da estranha estrutura do node_modules que o pnpm cria. Por que não é plano? Onde estão todas as sub-dependências?]]></description>
            <content:encoded><![CDATA[<p>Novos usuários do pnpm frequentemente me perguntam acerca da estranha estrutura do <code>node_modules</code> que o pnpm cria. Por que não é plano? Onde estão todas as sub-dependências?</p><blockquote><p>Vou assumir que os leitores do artigo já estão familiarizados com o <code>node_modules</code> plano criado pelo npm e Yarn. Se você não entende por que o npm 3 teve que começar a usar <code>node_modules</code> planos na v3, você pode encontrar um pouco da história em <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">Por que devemos usar o pnpm?</a>.</p></blockquote><p>Então, por que o <code>node_modules</code> do pnpm é incomum? Vamos criar dois diretórios e executar <code>npm add express</code> em um deles e <code>pnpm add express</code> no outro. Aqui está o início do <code>node_modules</code> do primeiro diretório:</p><pre><code class="language-text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express
</code></pre><p>Você pode ver todo o diretório <a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">aqui</a>.</p><p>E é isso que você obtém no <code>node_modules</code> criado pelo pnpm:</p><pre><code class="language-text">.pnpm
.modules.yaml
express
</code></pre><p>Você pode conferir <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">aqui</a>.</p><p>Então, onde estão todas as dependências? Existe apenas uma pasta em <code>node_modules</code> chamada <code>.pnpm</code> e um link simbólico chamado <code>express</code>. Bem, instalamos apenas <code>express</code>, então esse é o único pacote que sua aplicação tem que ter acesso</p><blockquote><p>Leia mais sobre porque o rigor do pnpm é uma coisa boa <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">aqui</a></p></blockquote><p>Vamos ver o que está dentro de <code>express</code>:</p><pre><code class="language-text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
    .modules.yaml
</code></pre><p><code>express</code> não tem <code>node_modules</code>? Onde estão todas as dependências de <code>express</code>?</p><p>O truque é que <code>express</code> é apenas um link simbólico. Quando o Node.js resolve dependências, ele usa suas localizações reais, portanto, não preserva links simbólicos. Mas onde está a localização real de <code>express</code>, você pode perguntar?</p><p>Aqui: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules/.pnpm/express@4.17.1/node_modules/express</a>.</p><p>OK, agora sabemos o propósito da pasta <code>.pnpm/</code>. <code>.pnpm/</code> armazena todos os pacotes em uma estrutura de pastas simples, então cada pacote pode ser encontrado em uma pasta nomeada por este padrão:</p><pre><code class="language-text">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;
</code></pre><p>Nós o chamamos de virtual store directory.</p><p>Essa estrutura plana evita os problemas de longos diretórios causados pelo <code>node_modules</code> aninhados criado pelo npm v2, mas mantém os pacotes isolados ao contrário dos <code>node_modules</code> criados pelo npm v3,4,5,6 ou Yarn v1.</p><p>Agora vamos olhar para a localização real de <code>express</code>:</p><pre><code class="language-text">  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>É uma farsa? Ainda falta <code>node_modules</code>! O segundo truque da estrutura <code>node_modules</code> do pnpm é que as dependências dos pacotes estão no mesmo nível de diretório em que a localização real da dependência. Portanto, as dependências de <code>express</code> não estão em <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code> mas em <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm/express@4.17.1/node_modules/</a>:</p><pre><code class="language-text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
</code></pre><p>Todas as dependências de <code>express</code> são links simbólicos para diretórios apropriados em <code>node_modules/.pnpm/</code>. Colocar dependências de <code>express</code> um nível acima permite evitar links simbólicos circulares.</p><p>Então, como você pode ver, mesmo que o <code>node_modules</code> do pnpm pareça incomum no início:</p><ol><li>é totalmente compatível com Node.js</li><li>os pacotes são bem agrupados com suas dependências</li></ol><p>A estrutura é um pouco <a href="/how-peers-are-resolved">mais complexa</a> para pacotes com dependências peer, mas a ideia é a mesma: usar links simbólicos para criar um aninhamento com uma estrutura de diretório simples.</p>]]></content:encoded>
        </item>
    </channel>
</rss>