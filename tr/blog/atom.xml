<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pnpm.io/tr/blog</id>
    <title>pnpm Blog</title>
    <updated>2021-12-29T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pnpm.io/tr/blog"/>
    <subtitle>pnpm Blog</subtitle>
    <icon>https://pnpm.io/tr/img/favicon.png</icon>
    <entry>
        <title type="html"><![CDATA[The year 2021 for pnpm]]></title>
        <id>/2021/12/29/yearly-update</id>
        <link href="https://pnpm.io/tr/blog/2021/12/29/yearly-update"/>
        <updated>2021-12-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[It is the end of the year and it was a good year for pnpm, so let's see how it went.]]></summary>
        <content type="html"><![CDATA[<p>It is the end of the year and it was a good year for pnpm, so let&#x27;s see how it went.</p><h2>Usage</h2><h3>Download Stats</h3><p>My goal this year was to beat Bower by the number of downloads. We were able to achieve this goal <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29">in November</a>:</p><p><img src="/img/blog/pnpm-vs-bower-stats.png"/></p><p>pnpm was downloaded about <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29">3 times more</a> in 2021 than in 2020:</p><p><img src="/img/blog/download-stats-2021.png"/></p><p>:::note</p><p>These stats don&#x27;t even measure all the different ways that pnpm may be installed! They only measure the downloads of the <a href="https://www.npmjs.com/package/pnpm">pnpm npm package</a>. This year we also added compiled binary versions of pnpm, which are shipped differently.</p><p>:::</p><h3>Docs visits</h3><p>We collect some unpersonalized stats from our docs using Google Analytics. In 2021, sometimes we had more than 2,000 unique visitors a week.</p><p><img src="/img/blog/ga-unique-visits-2021.png"/></p><p>Most of our users are from the United States and China.</p><p><img src="/img/blog/countries-2021.png"/></p><h3>GitHub stars</h3><p>Our <a href="https://github.com/pnpm/pnpm">main GitHub repository</a> received +5,000 stars this year.</p><p><img src="/img/blog/stars-2021.png"/></p><h3>New users</h3><p>Our biggest new user this year is <a href="https://github.com/pnpm/pnpm.github.io/pull/89">Bytedance</a> (the company behind TikTok).</p><p>Also, many great open-source projects started to use pnpm. Some switched to pnpm because of its great support of monorepos:</p><ul><li><a href="https://github.com/vuejs/vue-next">Vue</a></li><li><a href="https://github.com/vitejs/vite">Vite</a></li><li>and <a href="https://pnpm.io/workspaces#usage-examples">others</a></li></ul><p>Some switched because they like how efficient, fast, and beautiful pnpm is:</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419">Browserslist</a></li></ul><h2>Feature Highlights</h2><h3>New lockfile format (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0">v6.0.0</a>)</h3><p>One of the first and most important changes this year was the new <code>pnpm-lock.yaml</code> format. This was a breaking change, so we had to release v6. But it was a success. The old lockfile was causing Git conflicts frequently. Since the new format was introduced, we did not receive any complaints about Git conflicts.</p><h3>Managing Node.js versions (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0">v6.12.0</a>)</h3><p>We shipped a new command (<code>pnpm env</code>) that allows to manage Node.js versions. So you may use pnpm instead of Node.js version managers like nvm or Volta.</p><p>Also, pnpm is shipped as a standalone executable, so you can run it even with no Node.js preinstalled on the system.</p><h3>Injecting local dependencies (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0">v6.20.0</a>)</h3><p>You may &quot;inject&quot; a local dependency. By default, local dependencies are symlinked to <code>node_modules</code> but with this new feature you may instruct pnpm to hard link the files of the package instead.</p><h3>Improved reporting of peer dependency issues (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0">v6.24.0</a>)</h3><p>Peer dependency issues used to be printed as plain text and it was hard to understand them. They are now all grouped and printed in a nice hierarchy structure.</p><h2>The Competition</h2><h3>Yarn</h3><p>Yarn added a pnpm linker in <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-">v3.1</a>. So Yarn can create a similar node-modules directory structure to the one that pnpm creates.</p><p>Also, the Yarn team plans to implement a content-addressable storage to be more disk space efficient.</p><h3>npm</h3><p>The npm team decided to also adopt the symlinked node-modules directory structure that pnpm uses (related <a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md">RFC</a>).</p><h3>Others</h3><p><a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1">Bun</a> written in Zig and <a href="https://github.com/voltpkg/volt">Volt</a> written in Rust both claim to be faster than npm/Yarn/pnpm. I did not benchmark these new package managers yet.</p><h2>Future Plans</h2><p>Faster, better, best.</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[pnpm ile Node Modules yapılandırma seçenekleri]]></title>
        <id>/2020/10/17/node-modules-configuration-options-with-pnpm</id>
        <link href="https://pnpm.io/tr/blog/2020/10/17/node-modules-configuration-options-with-pnpm"/>
        <updated>2020-10-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[nodemodules dizini oluşturmanın birçok yolu vardır. Amacınız en kurallı olanı oluşturmak olmalıdır, ancak bu mümkün değilse, serbest bir nodemodules yapmak için seçenekler de vardır.]]></summary>
        <content type="html"><![CDATA[<p>node_modules dizini oluşturmanın birçok yolu vardır. Amacınız en kurallı olanı oluşturmak olmalıdır, ancak bu mümkün değilse, serbest bir node_modules yapmak için seçenekler de vardır.</p><h2>Varsayılan kurulum</h2><p>Varsayılan olarak pnpm v5, yarı kurallı bir node_modules oluşturur. Yarı kurallı (birkaç istisna dışında) bağımlılık olarak <code>package.json</code>&#x27;a eklenen paketleri gerektirebileceği anlamına gelir. Buna rağmen, bağımlılıklarınız herhangi bir pakete erişebilir olacaktır.</p><p>Varsayılan yapılandırma şöyle görünür:</p><pre><code class="language-ini">; Tüm paketler, node_modules/.pnpm/node_modules&#x27;a çıkarılır
hoist-pattern[]=*

; TypeScript&#x27;e uyumlanmak için tüm type&#x27;lar root&#x27;a çıkarılır
public-hoist-pattern[]=*types*

; ESLint ile ilgili tüm paketler de root&#x27;a çıkarılır
public-hoist-pattern[]=*eslint*
</code></pre><h2>Tak-Çalıştır. En kurallı yapılandırma</h2><p>pnpm, v5.9 &#x27;dan bu yana <a href="https://yarnpkg.com/features/pnp">Yarn&#x27;ın Plug&#x27;n&#x27;Play</a> &#x27;ini destekler. PnP ile hem uygulamanız hem de uygulamanızın bağımlılıkları yalnızca belirtilen bağımlılıklara erişebilecektir. Bu, <code>vinç=yanlış</code> ayarlamadan daha da kuralcıdır, çünkü bir monorepo içinde uygulamanız root projenin bağımlılıklarına bile erişemez.</p><p>Plug&#x27;n&#x27;Play&#x27;i kullanmak için şu ayarları yapın:</p><pre><code class="language-ini">node-linker=pnp
symlink=false
</code></pre><h2>Kurallı, geleneksel modül dizini</h2><p>PnP&#x27;yi kullanmaya henüz hazır değilseniz bile, hala kurallı olabilir ve çekme (hoist) yapılandırmasını false olarak ayarlayarak paketlerin yalnızca kendi bağımlılıklarına erişmesine izin verebilirsiniz:</p><pre><code class="language-ini">hoist=false
</code></pre><p>Ancak, bağımlılıklarınızın bazıları bağımlılıkları olmayan paketlere erişmeye çalışıyorsa, iki seçeneğiniz vardır:</p><ol><li><p>Paketteki manifestoya eksik bağımlılığı eklemek için <code>pnpmfile.js</code> oluşturun ve <a href="/pnpmfile">hook</a> kullanın.</p></li><li><p><code>hoist-pattern</code> ayarına bir kalıp ekleyin. Örneğin, bulunamayan modül <code>babel-core</code> ise, aşağıdaki ayarı <code>.npmrc</code>&#x27;ye ekleyin:</p><pre><code class="language-ini">hoist-pattern[]=babel-core
</code></pre></li></ol><h2>En kötü ihtimalle - root&#x27;u yukarı çekme</h2><p>Bazı araçlar, her şeyi sanal kayıt alanı (virtual store) &#x27;nın root&#x27;una ve bazısını da direkt root&#x27;a taşıyan varsayılan pnpm yapılandırmasıyla bile çalışmayabilir. Bu durumda, her şeyi ya da bir bağımlılık alt kümesini, modules dizininin root&#x27;una çekebilirsiniz.</p><p>Her şeyi node_modules&#x27;ın kök dizini(root)&#x27;ne kaldırmak:</p><pre><code class="language-ini">shamefully-hoist=true
</code></pre><p>Yalnızca bir kalıpla eşleşen paketleri yukarı çekin:</p><pre><code class="language-ini">public-hoist-pattern[]=babel-*
</code></pre>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Klasik node_modules yapısı artık tek yöntem değil]]></title>
        <id>/2020/05/27/flat-node-modules-is-not-the-only-way</id>
        <link href="https://pnpm.io/tr/blog/2020/05/27/flat-node-modules-is-not-the-only-way"/>
        <updated>2020-05-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Yeni pnpm kullanıcıları sık sık bana pnpm'in yarattığı node_modules'ün garip yapısını soruyor. Neden düz yapıda değil? Tüm alt bağımlılıklar nerede?]]></summary>
        <content type="html"><![CDATA[<p>Yeni pnpm kullanıcıları sık sık bana pnpm&#x27;in yarattığı <code>node_modules</code>&#x27;ün garip yapısını soruyor. Neden düz yapıda değil? Tüm alt bağımlılıklar nerede?</p><blockquote><p>Makalenin okuyucularının npm ve Yarn tarafından oluşturulan <code>node_modules</code> yapısına zaten aşina olduğunu varsayacağım. Npm 3&#x27;ün neden v3&#x27;te <code>node_modules</code>&#x27;ün düz yapısını kullanmaya başlaması gerektiğini anlayamadıysanız, bazı eski kaynakları inceleyebilirsiniz: <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">Neden pnpm kullanmalıyız?</a>.</p></blockquote><p>Öyleyse neden pnpm&#x27;in <code>node_modules</code>&#x27;ü olağandışı? İki dizin oluşturalım ve birinde <code>npm add express</code>, diğerinde ise <code>pnpm add express</code> komutlarını çalıştıralım. İşte ilk dizinin <code>node_modules</code>&#x27;ünden elde ettiğiniz klasör yapısı:</p><pre><code class="language-text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express
</code></pre><p>Klasör yapısının tamamını <a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">burada</a> görebilirsiniz.</p><p>Ve bu ise, pnpm tarafından oluşturulan <code>node_modules</code>:</p><pre><code class="language-text">.pnpm
.modules.yaml
express
</code></pre><p><a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">Buradan</a> kontrol edebilirsiniz.</p><p>Peki, tüm bu bağımlılıklar nerede? Görüldüğü üzere, <code>node_modules</code>&#x27;te <code>.pnpm</code> adında yalnızca bir klasör ve <code>express</code> adında bir sembolik bağlantı var. Eh, biz zaten sadece <code>express</code> yükledik, bu yüzden uygulamanızın erişmesi gereken tek paket bu</p><blockquote><p>pnpm&#x27;in katı kurallılığının neden iyi bir şey olduğu hakkında <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308"> daha fazla bilgi </a> edinin</p></blockquote><p>Bakalım, <code>express</code> içinde neler var:</p><pre><code class="language-text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
    .modules.yaml
</code></pre><p><code>express</code>&#x27;in <code>node_modules</code>&#x27;ü yok mu? <code>express</code>&#x27;in tüm bağımlılıkları nerede?</p><p>İşin püf noktası, <code>express</code>&#x27;in sadece bir sembolik bağlantı olmasıdır. Node.js bağımlılıkları çözdüğünde, onların gerçek konumlarını kullanır, bu nedenle sembolik bağlantıları korumaz. Ancak, <code>express</code>&#x27;in gerçek konumu nerede diye sorabilirsiniz?</p><p>İşte burada: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules/.pnpm/express@4.17.1/node_modules/express</a>.</p><p>Tamam, şimdi <code>.pnpm/</code> klasörünün amacını biliyoruz. <code>.pnpm/</code> tüm paketleri düz bir klasör yapısında saklar, böylece her paket bu modelle adlandırılan bir klasörde bulunabilir:</p><pre><code class="language-text">.pnpm/&lt;paket-adı&gt;@&lt;versiyon&gt;/node_modules/&lt;paket-adı&gt;
</code></pre><p>Biz buna sanal saklama dizini diyoruz.</p><p>Bu düz yapı, npm v2 tarafından oluşturulan <code>node_modules</code>&#x27;ün neden olduğu iç içe dosya yolu sorunlarını önler, ancak npm v3,4,5,6 veya Yarn v1 tarafından oluşturulan düz <code>node_modules</code> yapısına gerek duymadan paketleri korur.</p><p>Şimdi, <code>express</code> &#x27;in gerçek konumuna bakalım:</p><pre><code class="language-text">  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>Bu bir dolandırıcılık mı? Hala <code>node_modules</code> yok! pnpm &#x27; nin <code>node_modules</code> yapısının ikinci hilesi, paketlerin bağımlılıklarının, bağımlı paketin gerçek konumlarının aynı dizin düzeyinde olmasıdır. Dolayısıyla <code>express</code>&#x27;in bağımlılıkları <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code>&#x27;ün içerisinde değil, <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm/express@4.17.1/node_modules/</a> içerisindedir:</p><pre><code class="language-text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
</code></pre><p><code>express</code>&#x27;in tüm bağımlılıkları, <code>node_modules/.pnpm/</code> içindeki uygun dizinlere sembolik bağlantılardır. <code>express</code>&#x27;in bağımlılıklarını bir seviye yukarı yerleştirmek dairesel sembolik bağlantılardan kaçınmayı sağlar.</p><p>Gördüğünüz gibi, pnpm&#x27;in <code>node_modules</code> yapısı ilk bakışta olağandışı görünse de:</p><ol><li>Tamamıyla Node.js uyumlu</li><li>paketler bağımlılıklarıyla güzel bir şekilde gruplandırılmıştır</li></ol><p>Eş bağımlılıkları olan paketler için yapı <a href="/how-peers-are-resolved">biraz daha karmaşık</a>, ancak fikir aynıdır: düz bir dizin yapısıyla iç içe yerleştirme oluşturmak için sembolik bağlantılar kullanmaktır.</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
</feed>