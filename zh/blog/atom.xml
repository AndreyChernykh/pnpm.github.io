<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pnpm.io/zh/blog</id>
    <title>pnpm Blog</title>
    <updated>2021-12-29T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pnpm.io/zh/blog"/>
    <subtitle>pnpm Blog</subtitle>
    <icon>https://pnpm.io/zh/img/favicon.png</icon>
    <entry>
        <title type="html"><![CDATA[pnpm 的 2021 年]]></title>
        <id>/2021/12/29/yearly-update</id>
        <link href="https://pnpm.io/zh/blog/2021/12/29/yearly-update"/>
        <updated>2021-12-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[现在是年底，对 pnpm 来说是个好年头，所以让我们看看它的进展情况。]]></summary>
        <content type="html"><![CDATA[<p>现在是年底，对 pnpm 来说是个好年头，所以让我们看看它的进展情况。</p><h2>使用量</h2><h3>下载统计</h3><p>我今年的目标是在下载量上击败 Bower。 我们在<a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29">11月</a>实现了这个目标：</p><p><img src="/img/blog/pnpm-vs-bower-stats.png"/></p><p>2021 年 pnpm 的下载量约为 2020 年的<a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29">3倍 </a>：</p><p><img src="/img/blog/download-stats-2021.png"/></p><p>:::note</p><p>这些统计数据甚至没有衡量 pnpm 可能被安装的所有不同的方式！ 他们只测量了 <a href="https://www.npmjs.com/package/pnpm">pnpm npm package</a> 的下载量。 今年我们还添加了 pnpm 的二进制编译版本，它们的交付的方式是不同的。</p><p>:::</p><h3>文档访问</h3><p>我们使用 Google Analytics 从我们的文档中收集了一些非个性化的统计数据。 在 2021 年，有时我们每周有超过 2,000 名独立访客。</p><p><img src="/img/blog/ga-unique-visits-2021.png"/></p><p>我们的大部分用户来自美国和中国。</p><p><img src="/img/blog/countries-2021.png"/></p><h3>GitHub stars</h3><p>我们的 <a href="https://github.com/pnpm/pnpm">主 GitHub 仓库</a> 今年获得了 +5,000 颗星。</p><p><img src="/img/blog/stars-2021.png"/></p><h3>新用户</h3><p>我们今年最大的新用户是 <a href="https://github.com/pnpm/pnpm.github.io/pull/89">Bytedance</a>（TikTok 背后的公司）。</p><p>此外，许多优秀的开源项目开始使用 pnpm。 有些人转而使用 pnpm 是因为它对 monorepos 的大力支持：</p><ul><li><a href="https://github.com/vuejs/vue-next">Vue</a></li><li><a href="https://github.com/vitejs/vite">Vite</a></li><li>和 <a href="https://github.com/vitejs/vite">其他</a>。</li></ul><p>有些人之所以切换为 pnpm，是因为他们喜欢 pnpm 的高效、快速和美观：</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419">Browserslist</a></li></ul><h2>功能亮点</h2><h3>新的锁文件格式（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0">v6.0.0</a>）</h3><p>今年第一个也是最重要的变化之一是新的 <code>pnpm-lock.yaml</code> 格式。 这是一个突破性的变化，所以我们不得不发布 v6。 但它是成功的。 旧的锁文件经常导致 Git 冲突。 由于引入了新格式，我们没有收到任何关于 Git 冲突的投诉。</p><h3>管理 Node.js 版本（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0">v6.12.0</a>）</h3><p>我们发布了一个允许管理 Node.js 版本的新命令（ <code>pnpm env</code> ）。 因此，您可以使用 pnpm 而不是像 nvm 或 Volta 这样的 Node.js 版本管理器。</p><p>此外，pnpm 是作为独立的可执行文件提供的，因此即使系统上没有预装 Node.js，您也可以运行它。</p><h3>注入本地依赖（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0">v6.20.0</a>）</h3><p>您可以 “inject” 本地依赖项。 默认情况下，本地依赖项被符号链接至 <code>node_modules</code>。但有了这个新功能，你可以指示 pnpm 硬链接包内的文件。</p><h3>改进了 peerDependency 问题的报告（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0">v6.24.0</a>）</h3><p>PeerDependency 问题曾经被打印为纯文本，很难理解。 它们现在都分组并打印在一个很好的层次结构中。</p><h2>竞争</h2><h3>Yarn</h3><p>Yarn 在 <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-">v3.1</a> 添加了 pnpm 链接器。 因此 Yarn 可以创建一个类似于 pnpm 创建的 node_modules 目录结构。</p><p>此外，Yarn 团队计划实现内容可寻址存储，以提高磁盘空间效率。</p><h3>npm</h3><p>Npm 团队决定也采用 pnpm 使用的符号链接的 node_modules 目录结构（相关 <a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md">RFC</a>）。</p><h3>Others</h3><p>用 Zig 编写的 <a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1">Bun</a> 以及 <a href="https://github.com/voltpkg/volt">Volt</a> 都声称比 npm/Yarn/pnpm 更快。 我还没有对这些新的包管理器进行基准测试。</p><h2>未来的计划</h2><p>更快，更好，最好。</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[pnpm的node_modules配置选项]]></title>
        <id>/2020/10/17/node-modules-configuration-options-with-pnpm</id>
        <link href="https://pnpm.io/zh/blog/2020/10/17/node-modules-configuration-options-with-pnpm"/>
        <updated>2020-10-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[创建node_modules目录结构有多种方式。 你一定想要创建最严格的结构，当然如果你当前的项目尚无法支持，你可以配置为不严格的。]]></summary>
        <content type="html"><![CDATA[<p>创建node_modules目录结构有多种方式。 你一定想要创建最严格的结构，当然如果你当前的项目尚无法支持，你可以配置为不严格的。</p><h2>默认配置</h2><p>默认情况下，pnpm v5将创建一个“半严格”的node_modules。 “半严格”意味着您的应用程序将只能导入 <code>package.json</code> 中列出的依赖项(但也有例外)。 然而，你所依赖的那些包将能访问任何其他的包。</p><p>默认配置如下所示：</p><pre><code class="language-ini">; 提升所有包到 node_modules/.pnpm/node_modules
hoist-pattern[]=*

; 提升所有名称包含types的包至根，以便Typescript能找到
public-hoist-pattern[]=*types*

; 提升所有ESLint相关的包至根
public-hoist-pattern[]=*eslint*
</code></pre><h2>Plug&#x27;n&#x27;Play. 最严格的配置</h2><p>自v5.9起，pnpm支持 <a href="https://yarnpkg.com/features/pnp">Yarn的Plug&#x27;n&#x27;Play</a>。 使用PnP，您的应用以及你所依赖的包都只能访问他们声明的依赖关系。 这比设置 <code>hoist = false</code> 更为严格，因为在monorepo中，您的应用甚至连根项目的依赖项也无法访问。</p><p>要使用 Plug&#x27;n&#x27;Play，请设置以下设置:</p><pre><code class="language-ini">node-linker=pnp
symlink=false
</code></pre><h2>严格的模块目录</h2><p>如果您尚未准备好使用PnP，也可以通过将提升配置设置为false来仅允许程序包访问其自身的依赖项，确保其“严格”性：</p><pre><code class="language-ini">hoist=false
</code></pre><p>但是，如果您的某些依赖项需要访问它们在依赖项中没有的程序包，则有两种选择：</p><ol><li><p>创建 <code>pnpmfile.js</code> 并使用一个 <a href="/pnpmfile">hook</a> 将缺少的依赖项添加到包的清单中。</p></li><li><p>添加到 <code>hoist-pattern</code> 中。 例如，如果未找到的模块是 <code>babel-core</code>，则将以下设置添加到 <code>.npmrc</code>：</p><pre><code class="language-ini">hoist-pattern[]=babel-core
</code></pre></li></ol><h2>最坏的情况 -- 提升至根</h2><p>即使使用pnpm的默认配置，某些工具也可能无法工作，默认配置下所有内容都悬挂在虚拟存储的根目录中，而某些软件包则悬挂在根目录中。 在这种情况下，您可以将所有内容或部分依赖关系提升到modules目录的根目录。</p><p>要将所有内容提升到node_modules的根目录：</p><pre><code class="language-ini">shamefully-hoist=true
</code></pre><p>按匹配规则提升:</p><pre><code class="language-ini">public-hoist-pattern[]=babel-*
</code></pre>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[平铺的结构不是 node_modules 的唯一实现方式]]></title>
        <id>/2020/05/27/flat-node-modules-is-not-the-only-way</id>
        <link href="https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way"/>
        <updated>2020-05-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Pnpm 的新用户们经常会问我关于 pnpm 创建的奇怪的 node_modules 结构。 为什么不是平铺的？ 次级依赖去哪了？]]></summary>
        <content type="html"><![CDATA[<p>Pnpm 的新用户们经常会问我关于 pnpm 创建的奇怪的 <code>node_modules</code> 结构。 为什么不是平铺的？ 次级依赖去哪了？</p><blockquote><p>我将默认这篇文章的读者已经熟悉了 npm 与 yarn 创建的平铺的 <code>node_modules</code>。 如果你不明白为什么 npm3 需要开始在 v3 中使用平铺的 <code>node_modules</code>，你可以在这里找到一些背景知识 <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">Why should we use pnpm?</a>。</p></blockquote><p>那么为什么 pnpm 的 <code>node_modules</code> 会如此不同寻常呢？ 让我们创建两个目录，并在其中一个执行 <code>npm add express</code>， 然后在另一个中执行 <code>pnpm add express</code>。 以下是你在第一个目录中的 <code>node_modules</code> 的顶级项目：</p><pre><code class="language-text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express
</code></pre><p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">这里</a>看到整个目录。</p><p>然后这一个<code>node_modules</code> 是你通过 pnpm 创建的得到的：</p><pre><code class="language-text">.pnpm
.modules.yaml
express
</code></pre><p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">这里</a>查看。</p><p>那么所有的（次级）依赖去哪了呢？ <code>node_modules</code> 中只有一个叫 <code>.pnpm</code> 的文件夹以及一个叫做 <code>express</code> 的符号链接。 不错，我们只安装了 <code>express</code>，所以它是唯一一个你的应用必须拥有访问权限的包。</p><blockquote><p>要了解关于为什么 pnpm （对依赖向访问控制）的严格把关是件好事，请阅读<a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">此文</a></p></blockquote><p>让我们看看在 <code>express</code> 中都有些什么：</p><pre><code class="language-text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
    .modules.yaml
</code></pre><p><code>express</code> 没有 <code>node_modules</code>? <code>express</code> 的所有依赖都去哪里了？</p><p>诀窍是 <code>express</code> 只是一个符号链接。 当 Node.js 解析依赖的时候，它使用这些依赖的真实位置，所以它不保留符号链接。 但是你可能就会问了，<code>express</code> 的真实位置在哪呢？</p><p>在这里：<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules/.pnpm/express@4.17.1/node_modules/express</a>。</p><p>OK，所以我们现在知道了 <code>.pnpm/</code> 文件夹的用途。 <code>.pnpm/</code> 以平铺的形式储存着所有的包，所以每个包都可以在这种命名模式的文件夹中被找到：</p><pre><code class="language-text">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;
</code></pre><p>我们称之为虚拟存储目录。</p><p>这个平铺的结构避免了 npm v2 创建的嵌套 <code>node_modules</code> 引起的长路径问题，但与 npm v3,4,5,6 或 yarn v1 创建的平铺的 <code>node_modules</code> 不同的是，它保留了包之间的相互隔离。</p><p>现在让我们看看 <code>express</code> 的真实位置：</p><pre><code class="language-text">  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>这是个骗局吗？ 还是没有 <code>node_modules</code>！ pnpm 的 <code>node_modules</code> 结构的第二个诀窍是包的依赖项与依赖包的实际位置位于同一目录级别。 所以 <code>express</code> 的依赖不在 <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code> 而是在 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm/express@4.17.1/node_modules/</a>：</p><pre><code class="language-text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
</code></pre><p><code>express</code> 所有的依赖都软链至了 <code>node_modules/.pnpm/</code> 中的对应目录。 把 <code>express</code> 的依赖放置在同一级别避免了循环的软链。</p><p>正如你所看到的，即使 pnpm 的 <code>node_modules</code> 结构一开始看起来很奇怪：</p><ol><li>它完全适配了 Node.js。</li><li>包与其依赖被完美地组织在一起。</li></ol><p>有 peer 依赖的包的结构<a href="/how-peers-are-resolved">更加复杂</a>一些，但思路是一样的：使用软链与平铺目录来构建一个嵌套结构。</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
</feed>